package convert

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"reflect"
	"sort"
	"strings"
	"unicode"

	"github.com/pelletier/go-toml/v2"
	"gopkg.in/yaml.v3"
)

func JSONToGoStruct(input string) (string, error) {
	data, err := decodeJSONValue(input)
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	sb.WriteString("package main\n\n")
	sb.WriteString("type AutoGenerated ")
	sb.WriteString(renderType(data, ""))
	sb.WriteString("\n")

	formatted, err := format.Source([]byte(sb.String()))
	if err != nil {
		return "", err
	}
	result := strings.TrimPrefix(string(formatted), "package main\n\n")
	return strings.TrimSpace(result), nil
}

func renderType(v any, indent string) string {
	switch val := v.(type) {
	case map[string]any:
		return renderStruct(val, indent)
	case []any:
		return "[]" + renderArrayElement(val, indent)
	case json.Number:
		if looksInteger(val) {
			return "int"
		}
		return "float64"
	case string:
		return "string"
	case bool:
		return "bool"
	case nil:
		return "interface{}"
	default:
		return "interface{}"
	}
}

func renderStruct(obj map[string]any, indent string) string {
	var buf strings.Builder
	buf.WriteString("struct {\n")
	keys := make([]string, 0, len(obj))
	for k := range obj {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	seen := map[string]int{}
	for _, key := range keys {
		fieldName := exportName(key)
		if fieldName == "" {
			fieldName = "Field"
		}
		if count := seen[fieldName]; count > 0 {
			fieldName = fmt.Sprintf("%s%d", fieldName, count+1)
		}
		seen[fieldName]++
		fieldType := renderType(obj[key], indent+"\t")
		buf.WriteString(indent)
		buf.WriteString("\t")
		buf.WriteString(fieldName)
		buf.WriteString(" ")
		buf.WriteString(fieldType)
		buf.WriteString(fmt.Sprintf(" `json:\"%s\"`\n", key))
	}
	buf.WriteString(indent)
	buf.WriteString("}")
	return buf.String()
}

func renderArrayElement(arr []any, indent string) string {
	var elementType string
	for _, item := range arr {
		if item == nil {
			continue
		}
		t := renderType(item, indent)
		if elementType == "" {
			elementType = t
			continue
		}
		if elementType != t {
			return "interface{}"
		}
	}
	if elementType == "" {
		return "interface{}"
	}
	return elementType
}

func looksInteger(num json.Number) bool {
	if strings.ContainsRune(num.String(), '.') {
		return false
	}
	_, err := num.Int64()
	return err == nil
}

func exportName(key string) string {
	var runes []rune
	capNext := true
	for _, r := range key {
		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			if capNext {
				runes = append(runes, unicode.ToUpper(r))
				capNext = false
			} else {
				runes = append(runes, r)
			}
		} else {
			capNext = true
		}
	}
	out := string(runes)
	out = strings.TrimLeftFunc(out, func(r rune) bool {
		return !unicode.IsLetter(r) && r != '_'
	})
	return out
}

func GoStructToJSON(src string) (string, error) {
	source := strings.TrimSpace(src)
	if source == "" {
		return "", errors.New("empty input")
	}
	if !strings.Contains(source, "package ") {
		source = "package main\n" + source
	}
	fileSet := token.NewFileSet()
	file, err := parser.ParseFile(fileSet, "input.go", source, parser.AllErrors)
	if err != nil {
		return "", err
	}
	typeMap := collectTypeSpecs(file)
	root := firstTypeExpr(file)
	if root == nil {
		return "", errors.New("no type declarations found")
	}
	value := sampleValue(root, typeMap, map[string]int{}, 0)
	buf := &bytes.Buffer{}
	enc := json.NewEncoder(buf)
	enc.SetEscapeHTML(false)
	enc.SetIndent("", "  ")
	if err := enc.Encode(value); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func collectTypeSpecs(file *ast.File) map[string]ast.Expr {
	types := make(map[string]ast.Expr)
	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok || ts.Name == nil {
				continue
			}
			types[ts.Name.Name] = ts.Type
		}
	}
	return types
}

func firstTypeExpr(file *ast.File) ast.Expr {
	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			if ts, ok := spec.(*ast.TypeSpec); ok {
				return ts.Type
			}
		}
	}
	return nil
}

func sampleValue(expr ast.Expr, types map[string]ast.Expr, seen map[string]int, depth int) any {
	if depth > 8 {
		return nil
	}
	switch t := expr.(type) {
	case *ast.StructType:
		obj := make(map[string]any)
		for _, field := range t.Fields.List {
			name := jsonFieldName(field)
			if name == "" {
				continue
			}
			val := sampleValue(field.Type, types, seen, depth+1)
			obj[name] = val
		}
		return obj
	case *ast.ArrayType:
		elem := sampleValue(t.Elt, types, seen, depth+1)
		return []any{elem}
	case *ast.StarExpr:
		return sampleValue(t.X, types, seen, depth+1)
	case *ast.Ident:
		if basic := basicSample(t.Name); basic != nil {
			return basic
		}
		if expr, ok := types[t.Name]; ok {
			seen[t.Name]++
			if seen[t.Name] > 2 {
				return nil
			}
			return sampleValue(expr, types, seen, depth+1)
		}
		return map[string]any{}
	case *ast.MapType:
		return map[string]any{}
	case *ast.InterfaceType:
		return any(nil)
	case *ast.SelectorExpr:
		if basic := basicSample(t.Sel.Name); basic != nil {
			return basic
		}
		return nil
	default:
		return nil
	}
}

func basicSample(name string) any {
	switch name {
	case "string":
		return ""
	case "bool":
		return false
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr":
		return 0
	case "float32", "float64":
		return 0.0
	case "interface{}", "any":
		return nil
	case "byte":
		return 0
	}
	return nil
}

func jsonFieldName(field *ast.Field) string {
	if field.Tag != nil {
		tag := strings.Trim(field.Tag.Value, "`")
		val := reflect.StructTag(tag).Get("json")
		if val != "" && val != "-" {
			part := strings.Split(val, ",")[0]
			if part != "" {
				return part
			}
		}
	}
	if len(field.Names) == 0 {
		return ""
	}
	return lowerFirst(field.Names[0].Name)
}

func lowerFirst(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

func JSONToYAML(input string) (string, error) {
	data, err := decodeJSONValue(input)
	if err != nil {
		return "", err
	}
	return encodeYAML(data)
}

func YAMLToJSON(input string) (string, error) {
	var data interface{}
	if err := yaml.Unmarshal([]byte(input), &data); err != nil {
		return "", err
	}
	normalized := normalizeYAML(data)
	buf := &bytes.Buffer{}
	enc := json.NewEncoder(buf)
	enc.SetEscapeHTML(false)
	enc.SetIndent("", "  ")
	if err := enc.Encode(normalized); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func JSONToTOML(input string) (string, error) {
	data, err := decodeJSONValue(input)
	if err != nil {
		return "", err
	}
	obj, ok := data.(map[string]any)
	if !ok {
		return "", errors.New("TOML 根元素必須是物件")
	}
	out, err := toml.Marshal(normalizeJSONNumbers(obj).(map[string]any))
	if err != nil {
		return "", err
	}
	return string(out), nil
}

func TOMLToJSON(input string) (string, error) {
	var data map[string]any
	if err := toml.Unmarshal([]byte(input), &data); err != nil {
		return "", err
	}
	buf := &bytes.Buffer{}
	enc := json.NewEncoder(buf)
	enc.SetEscapeHTML(false)
	enc.SetIndent("", "  ")
	if err := enc.Encode(data); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func YAMLToGoStruct(input string) (string, error) {
	jsonStr, err := YAMLToJSON(input)
	if err != nil {
		return "", err
	}
	return JSONToGoStruct(jsonStr)
}

func TOMLToGoStruct(input string) (string, error) {
	jsonStr, err := TOMLToJSON(input)
	if err != nil {
		return "", err
	}
	return JSONToGoStruct(jsonStr)
}

func GoStructToYAML(src string) (string, error) {
	jsonStr, err := GoStructToJSON(src)
	if err != nil {
		return "", err
	}
	return JSONToYAML(jsonStr)
}

func GoStructToTOML(src string) (string, error) {
	jsonStr, err := GoStructToJSON(src)
	if err != nil {
		return "", err
	}
	return JSONToTOML(jsonStr)
}

func GoStructToSchema(src string) (string, error) {
	jsonStr, err := GoStructToJSON(src)
	if err != nil {
		return "", err
	}
	return JSONToSchema(jsonStr)
}

func JSONToSchema(input string) (string, error) {
	data, err := decodeJSONValue(input)
	if err != nil {
		return "", err
	}
	schema := buildSchema(data)
	formatted, err := json.MarshalIndent(schema, "", "  ")
	if err != nil {
		return "", err
	}
	return string(formatted), nil
}

func SchemaToJSON(input string) (string, error) {
	schema, err := decodeJSONValue(input)
	if err != nil {
		return "", err
	}
	sample := sampleFromSchema(schema)
	buf := &bytes.Buffer{}
	enc := json.NewEncoder(buf)
	enc.SetEscapeHTML(false)
	enc.SetIndent("", "  ")
	if err := enc.Encode(sample); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func SchemaToGoStruct(input string) (string, error) {
	jsonStr, err := SchemaToJSON(input)
	if err != nil {
		return "", err
	}
	return JSONToGoStruct(jsonStr)
}

func decodeJSONValue(input string) (any, error) {
	dec := json.NewDecoder(strings.NewReader(input))
	dec.UseNumber()
	var data any
	if err := dec.Decode(&data); err != nil {
		return nil, err
	}
	return data, nil
}

func normalizeJSONNumbers(v any) any {
	switch val := v.(type) {
	case map[string]any:
		res := make(map[string]any, len(val))
		for k, vv := range val {
			res[k] = normalizeJSONNumbers(vv)
		}
		return res
	case []any:
		for i, item := range val {
			val[i] = normalizeJSONNumbers(item)
		}
		return val
	case json.Number:
		if i, err := val.Int64(); err == nil {
			return i
		}
		if f, err := val.Float64(); err == nil {
			return f
		}
		return val.String()
	default:
		return v
	}
}

func normalizeYAML(v any) any {
	switch val := v.(type) {
	case map[string]any:
		res := make(map[string]any, len(val))
		for k, vv := range val {
			res[k] = normalizeYAML(vv)
		}
		return res
	case map[interface{}]interface{}:
		res := make(map[string]any, len(val))
		for k, vv := range val {
			key := fmt.Sprint(k)
			res[key] = normalizeYAML(vv)
		}
		return res
	case []interface{}:
		for i, item := range val {
			val[i] = normalizeYAML(item)
		}
		return val
	default:
		return val
	}
}

func encodeYAML(data any) (string, error) {
	buf := &bytes.Buffer{}
	enc := yaml.NewEncoder(buf)
	enc.SetIndent(2)
	if err := enc.Encode(data); err != nil {
		_ = enc.Close()
		return "", err
	}
	if err := enc.Close(); err != nil {
		return "", err
	}
	return strings.TrimRight(buf.String(), "\n"), nil
}

func buildSchema(v any) map[string]any {
	switch val := v.(type) {
	case map[string]any:
		props := make(map[string]any, len(val))
		keys := make([]string, 0, len(val))
		for k := range val {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			props[k] = buildSchema(val[k])
		}
		schema := map[string]any{
			"type":       "object",
			"properties": props,
		}
		if len(keys) > 0 {
			schema["required"] = keys
		}
		return schema
	case []any:
		schema := map[string]any{
			"type": "array",
		}
		var sample any
		for _, item := range val {
			if item != nil {
				sample = item
				break
			}
		}
		if sample == nil && len(val) > 0 {
			sample = val[0]
		}
		if sample == nil {
			schema["items"] = map[string]any{"type": "string"}
		} else {
			schema["items"] = buildSchema(sample)
		}
		return schema
	case json.Number:
		return map[string]any{"type": "number"}
	case string:
		return map[string]any{"type": "string"}
	case bool:
		return map[string]any{"type": "boolean"}
	case nil:
		return map[string]any{"type": "null"}
	default:
		return map[string]any{"type": "string"}
	}
}

func sampleFromSchema(schema any) any {
	switch s := schema.(type) {
	case map[string]any:
		switch schemaType(s) {
		case "array":
			items, ok := s["items"]
			if !ok {
				return []any{}
			}
			return []any{sampleFromSchema(items)}
		case "string":
			if def, ok := s["default"]; ok {
				return def
			}
			if enums, ok := s["enum"].([]any); ok && len(enums) > 0 {
				return enums[0]
			}
			return ""
		case "number", "integer":
			if def, ok := s["default"]; ok {
				return def
			}
			return 0.0
		case "boolean":
			if def, ok := s["default"]; ok {
				return def
			}
			return false
		case "null":
			return nil
		case "object":
			props := map[string]any{}
			if m, ok := s["properties"].(map[string]any); ok {
				keys := make([]string, 0, len(m))
				for k := range m {
					keys = append(keys, k)
				}
				sort.Strings(keys)
				for _, k := range keys {
					props[k] = sampleFromSchema(m[k])
				}
			}
			return props
		default:
			return map[string]any{}
		}
	case []any:
		if len(s) == 0 {
			return nil
		}
		return sampleFromSchema(s[0])
	default:
		return nil
	}
}

func schemaType(m map[string]any) string {
	switch t := m["type"].(type) {
	case string:
		return t
	case []any:
		for _, v := range t {
			if s, ok := v.(string); ok && s != "null" {
				return s
			}
		}
		if len(t) > 0 {
			if s, ok := t[0].(string); ok {
				return s
			}
		}
	}
	return "object"
}
