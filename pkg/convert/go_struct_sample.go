package convert

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"sort"
	"strings"
)

func JSONToGoStruct(input string) (string, error) {
	data, err := decodeJSONValue(input)
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	sb.WriteString("package main\n\n")
	sb.WriteString("type AutoGenerated ")
	sb.WriteString(renderType(data))
	sb.WriteString("\n")

	formatted, err := format.Source([]byte(sb.String()))
	if err != nil {
		return "", err
	}
	result := strings.TrimPrefix(string(formatted), "package main\n\n")
	return strings.TrimSpace(result), nil
}

func renderType(v any) string {
	switch val := v.(type) {
	case map[string]any:
		return renderStruct(val)
	case []any:
		return "[]" + renderArrayElement(val)
	case json.Number:
		if looksInteger(val) {
			return "int"
		}
		return "float64"
	case string:
		return "string"
	case bool:
		return "bool"
	case nil:
		return "interface{}"
	default:
		return "interface{}"
	}
}

func renderStruct(obj map[string]any) string {
	var buf strings.Builder
	buf.WriteString("struct {\n")
	keys := make([]string, 0, len(obj))
	for k := range obj {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	seen := map[string]int{}
	for _, key := range keys {
		fieldName := exportName(key)
		if fieldName == "" {
			fieldName = "Field"
		}
		if count := seen[fieldName]; count > 0 {
			fieldName = fieldName + fmt.Sprintf("%d", count+1)
		}
		seen[fieldName]++
		fieldType := renderType(obj[key])
		buf.WriteString("\t")
		buf.WriteString(fieldName)
		buf.WriteString(" ")
		buf.WriteString(fieldType)
		buf.WriteString(fmt.Sprintf(" `json:\"%s\"`\n", key))
	}
	buf.WriteString("}")
	return buf.String()
}

func renderArrayElement(arr []any) string {
	var elementType string
	for _, item := range arr {
		if item == nil {
			continue
		}
		t := renderType(item)
		if elementType == "" {
			elementType = t
			continue
		}
		if elementType != t {
			return "interface{}"
		}
	}
	if elementType == "" {
		return "interface{}"
	}
	return elementType
}

func GoStructToJSON(src string) (string, error) {
	value, _, err := parseGoStructValue(src)
	if err != nil {
		return "", err
	}
	return encodeJSON(value)
}

func parseGoStructValue(src string) (any, string, error) {
	source := strings.TrimSpace(src)
	if source == "" {
		return nil, "", errors.New("empty input")
	}
	if !strings.Contains(source, "package ") {
		source = "package main\n" + source
	}
	fileSet := token.NewFileSet()
	file, err := parser.ParseFile(fileSet, "input.go", source, parser.AllErrors)
	if err != nil {
		return nil, "", err
	}
	typeMap := collectTypeSpecs(file)
	spec := firstTypeSpec(file)
	if spec == nil {
		return nil, "", errors.New("no type declarations found")
	}
	value := sampleValue(spec.Type, typeMap, map[string]int{}, 0)
	return value, spec.Name.Name, nil
}

func encodeJSON(value any) (string, error) {
	buf := &bytes.Buffer{}
	enc := json.NewEncoder(buf)
	enc.SetEscapeHTML(false)
	enc.SetIndent("", "  ")
	if err := enc.Encode(value); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func collectTypeSpecs(file *ast.File) map[string]ast.Expr {
	types := make(map[string]ast.Expr)
	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok || ts.Name == nil {
				continue
			}
			types[ts.Name.Name] = ts.Type
		}
	}
	return types
}

func firstTypeSpec(file *ast.File) *ast.TypeSpec {
	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			if ts, ok := spec.(*ast.TypeSpec); ok {
				return ts
			}
		}
	}
	return nil
}

func sampleValue(expr ast.Expr, types map[string]ast.Expr, seen map[string]int, depth int) any {
	if depth > 8 {
		return nil
	}
	switch t := expr.(type) {
	case *ast.StructType:
		obj := make(map[string]any)
		for _, field := range t.Fields.List {
			name := jsonFieldName(field)
			if name == "" {
				continue
			}
			val := sampleValue(field.Type, types, seen, depth+1)
			obj[name] = val
		}
		return obj
	case *ast.ArrayType:
		elem := sampleValue(t.Elt, types, seen, depth+1)
		return []any{elem}
	case *ast.StarExpr:
		return sampleValue(t.X, types, seen, depth+1)
	case *ast.Ident:
		if basic := basicSample(t.Name); basic != nil {
			return basic
		}
		if expr, ok := types[t.Name]; ok {
			seen[t.Name]++
			if seen[t.Name] > 2 {
				return nil
			}
			return sampleValue(expr, types, seen, depth+1)
		}
		return map[string]any{}
	case *ast.MapType:
		return map[string]any{}
	case *ast.InterfaceType:
		return any(nil)
	case *ast.SelectorExpr:
		if t.Sel != nil {
			if basic := basicSample(t.Sel.Name); basic != nil {
				return basic
			}
		}
		return nil
	default:
		return nil
	}
}

func basicSample(name string) any {
	switch name {
	case "string":
		return ""
	case "bool":
		return false
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr":
		return 0
	case "float32", "float64":
		return 0.0
	case "interface{}", "any":
		return nil
	case "byte":
		return 0
	}
	return nil
}
