package convert

import (
	"encoding/json"
	"errors"
	"fmt"
	"go/ast"
	"regexp"
	"sort"
	"strings"
)

func JSONToGraphQL(input string) (string, error) {
	data, err := decodeJSONValue(input)
	if err != nil {
		return "", err
	}
	return buildGraphQLSchema("AutoGenerated", data)
}

func GraphQLToJSON(input string) (string, error) {
	schema := parseGraphQLSchema(input)
	if len(schema.order) == 0 {
		return "", errors.New("no GraphQL type definition found")
	}
	root := schema.order[0]
	val := schema.sampleType(root, map[string]int{})
	return encodeJSON(val)
}

func GoStructToGraphQL(src string) (string, error) {
	defs, err := parseGoStructDefinitions(src)
	if err != nil {
		return "", err
	}
	var blocks []string
	seen := map[string]bool{}
	for _, def := range defs {
		if seen[def.Name] {
			continue
		}
		blocks = append(blocks, renderGraphQLType(def))
		seen[def.Name] = true
	}
	if len(blocks) == 0 {
		return "", errors.New("no struct definition found")
	}
	return strings.Join(blocks, "\n\n"), nil
}

func GraphQLToGoStruct(input string) (string, error) {
	schema := parseGraphQLSchema(input)
	if len(schema.order) == 0 {
		return "", errors.New("no GraphQL type definition found")
	}
	var blocks []string
	for _, name := range schema.order {
		typ := schema.types[name]
		if typ == nil {
			continue
		}
		blocks = append(blocks, schema.renderGoStruct(typ))
	}
	return strings.Join(blocks, "\n\n"), nil
}

func buildGraphQLSchema(root string, data any) (string, error) {
	builder := newGraphQLBuilder()
	builder.addType(root, data)
	defs := builder.definitions()
	if len(defs) == 0 {
		return fmt.Sprintf("type %s {\n  value: %s\n}", root, scalarGraphQLType(data)), nil
	}
	return strings.Join(defs, "\n\n"), nil
}

type graphQLBuilder struct {
	defs  map[string]string
	order []string
}

func newGraphQLBuilder() *graphQLBuilder {
	return &graphQLBuilder{defs: make(map[string]string)}
}

func (b *graphQLBuilder) definitions() []string {
	res := make([]string, 0, len(b.defs))
	for _, name := range b.order {
		if def, ok := b.defs[name]; ok {
			res = append(res, def)
		}
	}
	return res
}

func (b *graphQLBuilder) addType(name string, v any) string {
	typeName := sanitizeTypeName(name)
	if typeName == "" {
		typeName = "Type"
	}
	switch val := v.(type) {
	case map[string]any:
		return b.buildObject(typeName, val)
	case []any:
		return "[" + b.arrayType(typeName+"Item", val) + "]"
	default:
		return scalarGraphQLType(val)
	}
}

func (b *graphQLBuilder) buildObject(name string, obj map[string]any) string {
	if _, ok := b.defs[name]; ok {
		return name
	}
	keys := make([]string, 0, len(obj))
	for k := range obj {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	var lines []string
	for _, key := range keys {
		fieldName := graphQLFieldName(key)
		if fieldName == "" {
			continue
		}
		fieldType := b.fieldType(name, key, obj[key])
		lines = append(lines, fmt.Sprintf("  %s: %s", fieldName, fieldType))
	}
	if len(lines) == 0 {
		lines = append(lines, "  dummy: String")
	}
	def := fmt.Sprintf("type %s {\n%s\n}", name, strings.Join(lines, "\n"))
	if _, ok := b.defs[name]; !ok {
		b.order = append(b.order, name)
	}
	b.defs[name] = def
	return name
}

func (b *graphQLBuilder) arrayType(name string, arr []any) string {
	var sample any
	for _, item := range arr {
		if item != nil {
			sample = item
			break
		}
	}
	if sample == nil && len(arr) > 0 {
		sample = arr[0]
	}
	if sample == nil {
		return "String"
	}
	switch sample := sample.(type) {
	case map[string]any:
		return b.buildObject(sanitizeTypeName(name), sample)
	case []any:
		return "[" + b.arrayType(name+"Item", sample) + "]"
	default:
		return scalarGraphQLType(sample)
	}
}

func (b *graphQLBuilder) fieldType(parentName, field string, v any) string {
	switch val := v.(type) {
	case map[string]any:
		return b.buildObject(parentName+exportName(field), val)
	case []any:
		return "[" + b.arrayType(parentName+exportName(field)+"Item", val) + "]"
	default:
		return scalarGraphQLType(val)
	}
}

func scalarGraphQLType(v any) string {
	switch val := v.(type) {
	case json.Number:
		if looksInteger(val) {
			return "Int"
		}
		return "Float"
	case string:
		return "String"
	case bool:
		return "Boolean"
	case float64:
		return "Float"
	case int, int64, int32:
		return "Int"
	default:
		return "String"
	}
}

func sanitizeTypeName(name string) string {
	n := exportName(name)
	if n == "" {
		return "Type"
	}
	return n
}

func graphQLFieldName(name string) string {
	n := exportName(name)
	if n == "" {
		return ""
	}
	return lowerFirst(n)
}

type gqlSchema struct {
	order []string
	types map[string]*gqlType
}

type gqlType struct {
	Name   string
	Fields []gqlField
}

type gqlField struct {
	Name     string
	TypeName string
	List     bool
	Comment  string
}

func parseGraphQLSchema(src string) *gqlSchema {
	schema := &gqlSchema{
		order: []string{},
		types: make(map[string]*gqlType),
	}
	re := regexp.MustCompile(`type\s+([A-Za-z0-9_]+)\s*\{`)
	idx := 0
	for idx < len(src) {
		loc := re.FindStringSubmatchIndex(src[idx:])
		if loc == nil {
			break
		}
		name := src[idx+loc[2] : idx+loc[3]]
		bodyStart := idx + loc[1] - 1
		open := strings.Index(src[bodyStart:], "{")
		if open == -1 {
			break
		}
		openIdx := bodyStart + open
		closeIdx := findMatchingBrace(src, openIdx)
		if closeIdx == -1 {
			break
		}
		body := src[openIdx+1 : closeIdx]
		schema.addType(name, body)
		idx = closeIdx + 1
	}
	return schema
}

func (s *gqlSchema) addType(name, body string) {
	name = strings.TrimSpace(name)
	if name == "" || s.types[name] != nil {
		return
	}
	typ := &gqlType{Name: name}
	var pending []string
	lines := strings.Split(body, "\n")
	for _, raw := range lines {
		line := strings.TrimSpace(raw)
		if line == "" {
			continue
		}
		if strings.HasPrefix(line, "#") {
			pending = append(pending, strings.TrimSpace(strings.TrimPrefix(line, "#")))
			continue
		}
		if strings.Contains(line, "#") {
			parts := strings.SplitN(line, "#", 2)
			line = strings.TrimSpace(parts[0])
			pending = append(pending, strings.TrimSpace(parts[1]))
		}
		if line == "" || strings.HasPrefix(line, "type ") {
			continue
		}
		parts := strings.Split(line, ":")
		if len(parts) < 2 {
			continue
		}
		field := strings.TrimSpace(parts[0])
		typeExpr := strings.TrimSpace(parts[1])
		list := strings.HasPrefix(typeExpr, "[")
		typeExpr = strings.Trim(typeExpr, "[]!")
		comment := strings.Join(pending, "\n")
		pending = nil
		typ.Fields = append(typ.Fields, gqlField{
			Name:     field,
			TypeName: typeExpr,
			List:     list,
			Comment:  comment,
		})
	}
	s.types[name] = typ
	s.order = append(s.order, name)
}

func (s *gqlSchema) sampleType(name string, seen map[string]int) any {
	if seen[name] > 2 {
		return nil
	}
	if typ, ok := s.types[name]; ok {
		seen[name]++
		obj := make(map[string]any)
		for _, field := range typ.Fields {
			val := s.sampleField(field, seen)
			obj[field.Name] = val
		}
		return obj
	}
	return sampleGraphQLScalarByName(name)
}

func (s *gqlSchema) sampleField(field gqlField, seen map[string]int) any {
	value := s.sampleType(field.TypeName, seen)
	if field.List {
		if value == nil {
			return []any{}
		}
		return []any{value}
	}
	return value
}

func sampleGraphQLScalarByName(typeName string) any {
	switch typeName {
	case "Int":
		return 0
	case "Float":
		return 0.0
	case "Boolean":
		return false
	case "ID", "String":
		return ""
	default:
		return ""
	}
}

func (s *gqlSchema) renderGoStruct(typ *gqlType) string {
	var buf strings.Builder
	buf.WriteString(fmt.Sprintf("type %s struct {\n", typ.Name))
	for _, field := range typ.Fields {
		if field.Comment != "" {
			for _, line := range strings.Split(field.Comment, "\n") {
				line = strings.TrimSpace(line)
				if line == "" {
					continue
				}
				buf.WriteString("\t// " + line + "\n")
			}
		}
		goName := exportName(field.Name)
		if goName == "" {
			goName = "Field"
		}
		goType := graphQLTypeToGo(field.TypeName, field.List)
		tag := fmt.Sprintf("`json:\"%s\"`", lowerFirst(field.Name))
		buf.WriteString(fmt.Sprintf("\t%s %s %s\n", goName, goType, tag))
	}
	buf.WriteString("}")
	return buf.String()
}

func renderGraphQLType(def StructDefinition) string {
	var lines []string
	for _, field := range def.Fields {
		if field.Comment != "" {
			for _, line := range strings.Split(field.Comment, "\n") {
				line = strings.TrimSpace(strings.TrimPrefix(line, "//"))
				if line == "" {
					continue
				}
				lines = append(lines, "  # "+line)
			}
		}
		fieldName := lowerFirst(field.GoName)
		if fieldName == "" {
			fieldName = "field"
		}
		typeName := goTypeToGraphQL(field.TypeExpr, false)
		lines = append(lines, fmt.Sprintf("  %s: %s", fieldName, typeName))
	}
	if len(lines) == 0 {
		lines = append(lines, "  value: String")
	}
	return fmt.Sprintf("type %s {\n%s\n}", def.Name, strings.Join(lines, "\n"))
}

func graphQLTypeToGo(typeName string, list bool) string {
	var base string
	switch typeName {
	case "String", "ID":
		base = "string"
	case "Int":
		base = "int"
	case "Float":
		base = "float64"
	case "Boolean":
		base = "bool"
	default:
		base = typeName
	}
	if list {
		return "[]" + base
	}
	return base
}

func goTypeToGraphQL(expr ast.Expr, listContext bool) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return identGraphQLType(t.Name, listContext)
	case *ast.StarExpr:
		return goTypeToGraphQL(t.X, listContext)
	case *ast.ArrayType:
		return "[" + goTypeToGraphQL(t.Elt, false) + "]"
	case *ast.SelectorExpr:
		if t.Sel != nil {
			return identGraphQLType(t.Sel.Name, listContext)
		}
		return "String"
	default:
		return "String"
	}
}

func identGraphQLType(name string, list bool) string {
	switch name {
	case "string":
		return wrapList("String", list)
	case "int", "int32", "int64", "uint", "uint32", "uint64":
		return wrapList("Int", list)
	case "float32", "float64":
		return wrapList("Float", list)
	case "bool":
		return wrapList("Boolean", list)
	default:
		return wrapList(name, list)
	}
}

func wrapList(typeName string, list bool) string {
	if list {
		return "[" + typeName + "]"
	}
	return typeName
}
