package convert

import (
	"encoding/json"
	"errors"
	"fmt"
	"go/ast"
	"regexp"
	"sort"
	"strings"
	"unicode"
)

func JSONToProto(input string) (string, error) {
	data, err := decodeJSONValue(input)
	if err != nil {
		return "", err
	}
	return buildProtoSchema("AutoGenerated", data)
}

func ProtoToJSON(input string) (string, error) {
	schema := parseProtoSchema(input)
	if len(schema.order) == 0 {
		return "", errors.New("no protobuf message found")
	}
	root := schema.order[0]
	val := schema.sampleMessage(root, map[string]int{})
	return encodeJSON(val)
}

func GoStructToProto(src string) (string, error) {
	defs, err := parseGoStructDefinitions(src)
	if err != nil {
		return "", err
	}
	var messages []string
	seen := map[string]bool{}
	for _, def := range defs {
		if seen[def.Name] {
			continue
		}
		messages = append(messages, renderProtoMessage(def))
		seen[def.Name] = true
	}
	if len(messages) == 0 {
		return "", errors.New("no struct definition found")
	}
	return strings.Join(messages, "\n\n"), nil
}

func ProtoToGoStruct(input string) (string, error) {
	schema := parseProtoSchema(input)
	if len(schema.order) == 0 {
		return "", errors.New("no protobuf message found")
	}
	var blocks []string
	for _, name := range schema.order {
		msg := schema.messages[name]
		if msg == nil {
			continue
		}
		blocks = append(blocks, schema.renderGoStruct(msg))
	}
	return strings.Join(blocks, "\n\n"), nil
}

type protoBuilder struct {
	defs  map[string]string
	order []string
}

func newProtoBuilder() *protoBuilder {
	return &protoBuilder{defs: make(map[string]string)}
}

func buildProtoSchema(root string, data any) (string, error) {
	builder := newProtoBuilder()
	builder.addMessage(root, data)
	defs := builder.definitions()
	if len(defs) == 0 {
		return fmt.Sprintf("message %s {\n  string value = 1;\n}", root), nil
	}
	return strings.Join(defs, "\n\n"), nil
}

func (b *protoBuilder) definitions() []string {
	res := make([]string, 0, len(b.defs))
	for _, name := range b.order {
		if def, ok := b.defs[name]; ok {
			res = append(res, def)
		}
	}
	return res
}

func (b *protoBuilder) addMessage(name string, v any) string {
	typeName := sanitizeTypeName(name)
	switch val := v.(type) {
	case map[string]any:
		return b.buildMessage(typeName, val)
	case []any:
		return b.repeatedType(typeName+"Item", val).typeName
	default:
		return protoScalarType(val)
	}
}

type protoType struct {
	typeName string
	repeated bool
}

func (b *protoBuilder) buildMessage(name string, obj map[string]any) string {
	if _, ok := b.defs[name]; ok {
		return name
	}
	keys := make([]string, 0, len(obj))
	for k := range obj {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	fieldNum := 1
	var lines []string
	for _, key := range keys {
		field := b.typeForField(name, key, obj[key])
		fieldName := protoFieldName(key)
		if fieldName == "" {
			fieldName = fmt.Sprintf("field_%d", fieldNum)
		}
		prefix := ""
		if field.repeated {
			prefix = "repeated "
		}
		lines = append(lines, fmt.Sprintf("  %s%s %s = %d;", prefix, field.typeName, fieldName, fieldNum))
		fieldNum++
	}
	if len(lines) == 0 {
		lines = append(lines, "  string placeholder = 1;")
	}
	def := fmt.Sprintf("message %s {\n%s\n}", name, strings.Join(lines, "\n"))
	if _, ok := b.defs[name]; !ok {
		b.order = append(b.order, name)
	}
	b.defs[name] = def
	return name
}

func (b *protoBuilder) typeForField(parent, field string, v any) protoType {
	switch val := v.(type) {
	case map[string]any:
		typeName := b.buildMessage(parent+exportName(field), val)
		return protoType{typeName: typeName}
	case []any:
		t := b.repeatedType(parent+exportName(field)+"Item", val)
		t.repeated = true
		return t
	default:
		return protoType{typeName: protoScalarType(val)}
	}
}

func (b *protoBuilder) repeatedType(name string, arr []any) protoType {
	var sample any
	for _, item := range arr {
		if item != nil {
			sample = item
			break
		}
	}
	if sample == nil && len(arr) > 0 {
		sample = arr[0]
	}
	if sample == nil {
		return protoType{typeName: "string"}
	}
	switch val := sample.(type) {
	case map[string]any:
		typeName := b.buildMessage(sanitizeTypeName(name), val)
		return protoType{typeName: typeName}
	case []any:
		t := b.repeatedType(name+"Item", val)
		return protoType{typeName: t.typeName}
	default:
		return protoType{typeName: protoScalarType(sample)}
	}
}

func protoScalarType(v any) string {
	switch val := v.(type) {
	case json.Number:
		if looksInteger(val) {
			return "int32"
		}
		return "double"
	case string:
		return "string"
	case bool:
		return "bool"
	case float64:
		return "double"
	case int, int64, int32:
		return "int32"
	default:
		return "string"
	}
}

func renderProtoMessage(def StructDefinition) string {
	var lines []string
	fieldNum := 1
	for _, field := range def.Fields {
		if field.Comment != "" {
			for _, line := range strings.Split(field.Comment, "\n") {
				line = strings.TrimSpace(strings.TrimPrefix(line, "//"))
				if line == "" {
					continue
				}
				lines = append(lines, "  // "+line)
			}
		}
		fieldName := field.JSONName
		if fieldName == "" {
			fieldName = protoFieldName(field.GoName)
		}
		repeated, protoType := goTypeToProto(field.TypeExpr)
		prefix := ""
		if repeated {
			prefix = "repeated "
		}
		lines = append(lines, fmt.Sprintf("  %s%s %s = %d;", prefix, protoType, fieldName, fieldNum))
		fieldNum++
	}
	if len(lines) == 0 {
		lines = append(lines, "  string placeholder = 1;")
	}
	return fmt.Sprintf("message %s {\n%s\n}", def.Name, strings.Join(lines, "\n"))
}

func goTypeToProto(expr ast.Expr) (bool, string) {
	switch t := expr.(type) {
	case *ast.ArrayType:
		_, inner := goTypeToProto(t.Elt)
		return true, inner
	case *ast.StarExpr:
		return goTypeToProto(t.X)
	case *ast.Ident:
		return false, identProtoType(t.Name)
	case *ast.SelectorExpr:
		if t.Sel != nil {
			return false, identProtoType(t.Sel.Name)
		}
		return false, "string"
	default:
		return false, "string"
	}
}

func identProtoType(name string) string {
	switch name {
	case "string", "bool", "int64", "uint64", "int32", "uint32":
		return name
	case "float32":
		return "float"
	case "float64":
		return "double"
	case "int", "int8", "int16", "uint", "uint8", "uint16":
		return "int32"
	default:
		return name
	}
}

type protoFieldDef struct {
	Name     string
	TypeName string
	Repeated bool
	Comment  string
}

type protoMessage struct {
	Name   string
	Fields []protoFieldDef
}

type protoSchema struct {
	order    []string
	messages map[string]*protoMessage
}

func parseProtoSchema(src string) *protoSchema {
	ps := &protoSchema{
		order:    []string{},
		messages: make(map[string]*protoMessage),
	}
	parseProtoSection(src, ps)
	return ps
}

func parseProtoSection(src string, ps *protoSchema) {
	re := regexp.MustCompile(`message\s+([A-Za-z0-9_]+)\s*\{`)
	idx := 0
	for idx < len(src) {
		loc := re.FindStringSubmatchIndex(src[idx:])
		if loc == nil {
			break
		}
		name := src[idx+loc[2] : idx+loc[3]]
		start := idx + loc[0]
		openIdx := start + strings.Index(src[start:], "{")
		closeIdx := findMatchingBrace(src, openIdx)
		if closeIdx == -1 {
			break
		}
		body := src[openIdx+1 : closeIdx]
		ps.addMessage(name, body)
		parseProtoSection(body, ps)
		idx = closeIdx + 1
	}
}

func (ps *protoSchema) addMessage(name, body string) {
	name = strings.TrimSpace(name)
	if name == "" || ps.messages[name] != nil {
		return
	}
	msg := &protoMessage{Name: name}
	var pending []string
	lines := strings.Split(body, "\n")
	for _, raw := range lines {
		line := strings.TrimSpace(raw)
		if line == "" {
			continue
		}
		if strings.HasPrefix(line, "//") {
			pending = append(pending, strings.TrimSpace(strings.TrimPrefix(line, "//")))
			continue
		}
		if strings.Contains(line, "//") {
			parts := strings.SplitN(line, "//", 2)
			line = strings.TrimSpace(parts[0])
			pending = append(pending, strings.TrimSpace(parts[1]))
		}
		if line == "" || strings.HasPrefix(line, "message ") {
			continue
		}
		repeated := false
		if strings.HasPrefix(line, "repeated ") {
			repeated = true
			line = strings.TrimSpace(line[len("repeated "):])
		}
		line = strings.TrimSuffix(line, ";")
		eqIdx := strings.Index(line, "=")
		if eqIdx == -1 {
			continue
		}
		left := strings.TrimSpace(line[:eqIdx])
		parts := strings.Fields(left)
		if len(parts) < 2 {
			continue
		}
		fieldType := parts[0]
		fieldName := parts[1]
		comment := strings.Join(pending, "\n")
		pending = nil
		msg.Fields = append(msg.Fields, protoFieldDef{
			Name:     fieldName,
			TypeName: fieldType,
			Repeated: repeated,
			Comment:  comment,
		})
	}
	ps.messages[name] = msg
	ps.order = append(ps.order, name)
}

func (ps *protoSchema) sampleMessage(name string, seen map[string]int) any {
	if seen[name] > 2 {
		return nil
	}
	msg, ok := ps.messages[name]
	if !ok {
		return protoScalarValue(name)
	}
	seen[name]++
	obj := make(map[string]any)
	for _, field := range msg.Fields {
		val := ps.sampleField(field, seen)
		obj[field.Name] = val
	}
	return obj
}

func (ps *protoSchema) sampleField(field protoFieldDef, seen map[string]int) any {
	var value any
	if ps.messages[field.TypeName] != nil {
		value = ps.sampleMessage(field.TypeName, seen)
	} else {
		value = protoScalarValue(field.TypeName)
	}
	if field.Repeated {
		if value == nil {
			return []any{}
		}
		return []any{value}
	}
	return value
}

func protoScalarValue(typeName string) any {
	switch typeName {
	case "string", "bytes":
		return ""
	case "bool":
		return false
	case "float", "double":
		return 0.0
	case "int32", "uint32", "sint32", "fixed32":
		return 0
	case "int64", "uint64", "sint64", "fixed64":
		return 0
	default:
		return ""
	}
}

func (ps *protoSchema) renderGoStruct(msg *protoMessage) string {
	var buf strings.Builder
	buf.WriteString(fmt.Sprintf("type %s struct {\n", msg.Name))
	for _, field := range msg.Fields {
		if field.Comment != "" {
			for _, line := range strings.Split(field.Comment, "\n") {
				line = strings.TrimSpace(line)
				if line == "" {
					continue
				}
				buf.WriteString("\t// " + line + "\n")
			}
		}
		goName := exportName(field.Name)
		if goName == "" {
			goName = "Field"
		}
		goType := protoTypeToGo(field.TypeName, field.Repeated)
		jsonTag := fmt.Sprintf("`json:\"%s\"`", field.Name)
		buf.WriteString(fmt.Sprintf("\t%s %s %s\n", goName, goType, jsonTag))
	}
	buf.WriteString("}")
	return buf.String()
}

func protoTypeToGo(typeName string, repeated bool) string {
	var base string
	switch typeName {
	case "string", "bytes":
		base = "string"
	case "bool":
		base = "bool"
	case "float":
		base = "float32"
	case "double":
		base = "float64"
	case "int32", "uint32", "sint32", "fixed32":
		base = "int32"
	case "int64", "uint64", "sint64", "fixed64":
		base = "int64"
	default:
		base = typeName
	}
	if repeated {
		return "[]" + base
	}
	return base
}

func protoFieldName(name string) string {
	name = exportName(name)
	if name == "" {
		return ""
	}
	var buf strings.Builder
	for i, r := range name {
		if unicode.IsUpper(r) && i > 0 {
			buf.WriteByte('_')
		}
		buf.WriteRune(unicode.ToLower(r))
	}
	return buf.String()
}
