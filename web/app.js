const formats = [
	"JSON",
	"Go Struct",
	"YAML",
	"TOML",
	"XML",
	"JSON Schema",
	"GraphQL Schema",
	"Protobuf",
];

const samples = {
	JSON: '{\n  "name": "Ricky",\n  "age": 27\n}',
	XML: `<root>\n  <name>Ricky</name>\n  <age>27</age>\n</root>`,
	"Go Struct":
		'type AutoGenerated struct {\n  UserID string `json:"user_id"`\n}\n',
	YAML: "name: Ricky\nage: 27",
	TOML: 'name = "Ricky"\nage = 27',
	"JSON Schema": `{
  "type": "object",
  "properties": {
    "name": { "type": "string" },
    "age": { "type": "number" }
  },
  "required": ["name"]
}`,
	"GraphQL Schema": `type AutoGenerated {
  userID: String!
}`,
	Protobuf: `message AutoGenerated {
  string user_id = 1;
}`,
};

const coderTools = [
	{
		id: "coder-encode",
		mode: "encode",
		label: "Encode",
		description: "Base32/64/85/91 encodings.",
	},
	{
		id: "coder-decode",
		mode: "decode",
		label: "Decode",
		description: "Decode BaseX back to plain text.",
	},
	{
		id: "coder-hash",
		mode: "hash",
		label: "Hash",
		description: "Hashes from Go's stdlib.",
	},
];

const toolGroups = [
	{
		name: "Converters",
		tools: [
			{
				id: "format",
				label: "Format Converter",
				description: "Convert between structured data formats.",
			},
		],
	},
	{
		name: "Coder",
		tools: coderTools.map((tool) => ({
			id: tool.id,
			label: `${tool.label}`,
			description: tool.description,
		})),
	},
];

const coderToolModes = {};
coderTools.forEach((tool) => {
	coderToolModes[tool.id] = tool.mode;
});
const coderToolSet = new Set(Object.keys(coderToolModes));
const coderModes = ["encode", "decode", "hash"];
const coderModeTitles = {
	encode: "Encode",
	decode: "Decode",
	hash: "Hash",
};
let coderMode = "encode";

function isCoderToolId(toolId) {
	return coderToolSet.has(toolId);
}

const encodingGroups = [
	{
		id: "base32",
		label: "Base32",
		variants: [
			{ key: "base32_standard", label: "Standard" },
			{ key: "base32_standard_no_padding", label: "Standard · No padding" },
			{ key: "base32_hex", label: "Hex" },
			{ key: "base32_hex_no_padding", label: "Hex · No padding" },
		],
	},
	{
		id: "base64",
		label: "Base64",
		variants: [
			{ key: "base64_standard", label: "Standard" },
			{ key: "base64_raw_standard", label: "Standard · Raw" },
			{ key: "base64_url", label: "URL-safe" },
			{ key: "base64_raw_url", label: "URL-safe · Raw" },
		],
	},
	{
		id: "base85",
		label: "Base85",
		variants: [{ key: "base85_ascii85", label: "ASCII85" }],
	},
	{
		id: "base91",
		label: "Base91",
		variants: [{ key: "base91", label: "Standard" }],
	},
	{
		id: "base16",
		label: "Base16",
		variants: [{ key: "hex_upper", label: "Hex (uppercase)" }],
	},
];

const encodingVariantMap = new Map();
const allEncodingVariants = [];
encodingGroups.forEach((group) => {
	group.variants.forEach((variant) => {
		encodingVariantMap.set(variant.key, {
			group: group.label,
			label: variant.label,
		});
		allEncodingVariants.push({
			...variant,
			group: group.label,
		});
	});
});

let selectedDecoder =
	allEncodingVariants.length > 0 ? allEncodingVariants[0].key : "";

const hashGroups = [
	{
		label: "Message Digest",
		keys: ["md5", "sha1"],
	},
	{
		label: "SHA-2",
		keys: ["sha224", "sha256", "sha384", "sha512", "sha512_224", "sha512_256"],
	},
	{
		label: "Checksums",
		keys: ["crc32_ieee", "crc32_castagnoli", "crc64_iso", "crc64_ecma", "adler32"],
	},
	{
		label: "FNV",
		keys: ["fnv32", "fnv32a", "fnv64", "fnv64a", "fnv128", "fnv128a"],
	},
];

const hashLabels = {
	md5: "MD5",
	sha1: "SHA-1",
	sha224: "SHA-224",
	sha256: "SHA-256",
	sha384: "SHA-384",
	sha512: "SHA-512",
	sha512_224: "SHA-512/224",
	sha512_256: "SHA-512/256",
	crc32_ieee: "CRC32 (IEEE)",
	crc32_castagnoli: "CRC32 (Castagnoli)",
	crc64_iso: "CRC64 (ISO)",
	crc64_ecma: "CRC64 (ECMA)",
	adler32: "Adler32",
	fnv32: "FNV-1 32",
	fnv32a: "FNV-1a 32",
	fnv64: "FNV-1 64",
	fnv64a: "FNV-1a 64",
	fnv128: "FNV-1 128",
	fnv128a: "FNV-1a 128",
};

const coderModeDescriptions = {
	encode: "Encode text into multiple bases.",
	decode: "Decode text with your selected base.",
	hash: "Generate hashes provided by Go's standard library.",
};

const coderResultHints = {
	encode: "Base32 / Base64 / Base85 / Base91 / Hex",
	decode: "Decoded output",
	hash: "MD5 / SHA / CRC / FNV",
};

const coderPlaceholders = {
	encode: "輸入任意文字...",
	decode: "貼上要解碼的 Base32/64/85/91 內容...",
	hash: "輸入任意文字以產生 hash",
};

const toolInfo = {};
toolGroups.forEach((group) => {
	group.tools.forEach((tool) => {
		toolInfo[tool.id] = tool;
	});
});

const supportedFormats = new Set(formats);

const elements = {};
let currentTool = "format";
let currentKey = "JSON|Go Struct";
let wasmReady = false;
let debounceTimer = null;
let coderTimer = null;
let wasmInitPromise = null;

document.addEventListener("DOMContentLoaded", () => {
	cacheElements();
	initCoderControls();
	renderToolSidebar();
	initSidebarResizer();
	bindEvents();
	selectTool(currentTool);
	ensureMode();
	loadWasm();
});

function cacheElements() {
	elements.sidebar = document.getElementById("sidebar");
	elements.toolGroups = document.getElementById("toolGroups");
	elements.resizer = document.getElementById("sidebarResizer");
	elements.toolName = document.getElementById("toolName");
	elements.toolDesc = document.getElementById("toolDesc");
	elements.from = document.getElementById("fromSelect");
	elements.to = document.getElementById("toSelect");
	elements.swap = document.getElementById("swap");
	elements.copy = document.getElementById("copy");
	elements.clear = document.getElementById("clear");
	elements.input = document.getElementById("input");
	elements.output = document.getElementById("output");
	elements.status = document.getElementById("status");
	elements.inputLabel = document.getElementById("inputLabel");
	elements.outputLabel = document.getElementById("outputLabel");
	elements.formatInput = document.getElementById("formatInput");
	elements.minifyInput = document.getElementById("minifyInput");
	elements.formatOutput = document.getElementById("formatOutput");
	elements.minifyOutput = document.getElementById("minifyOutput");
	elements.converterWorkspace = document.getElementById("converterWorkspace");
	elements.coderWorkspace = document.getElementById("coderWorkspace");
	elements.coderInput = document.getElementById("coderInput");
	elements.coderResults = document.getElementById("coderResults");
	elements.coderWorkspaceTitle = document.getElementById(
		"coderWorkspaceTitle",
	);
	elements.decodeVariantWrap = document.getElementById("decodeVariantWrap");
	elements.decodeVariant = document.getElementById("decodeVariant");
	elements.coderResultHeading = document.getElementById("coderResultHeading");
	elements.coderResultHint = document.getElementById("coderResultHint");
	elements.coderModeHint = document.getElementById("coderModeHint");
}

function initCoderControls() {
	if (!elements.decodeVariant) return;
	const options = allEncodingVariants
		.map(
			(opt) =>
				`<option value="${opt.key}">${opt.group} · ${opt.label}</option>`,
		)
		.join("");
	elements.decodeVariant.innerHTML = options;
	if (
		selectedDecoder &&
		allEncodingVariants.some((variant) => variant.key === selectedDecoder)
	) {
		elements.decodeVariant.value = selectedDecoder;
	} else if (allEncodingVariants.length > 0) {
		selectedDecoder = allEncodingVariants[0].key;
		elements.decodeVariant.value = selectedDecoder;
	}
	updateCoderTexts();
	if (elements.coderResults) {
		renderCoderEmpty();
	}
}

function renderToolSidebar() {
	const nav = elements.toolGroups;
	toolGroups.forEach((group) => {
		const details = document.createElement("details");
		details.open = true;
		const summary = document.createElement("summary");
		summary.textContent = group.name;
		details.appendChild(summary);
		const wrapper = document.createElement("div");
		wrapper.className = "tool-buttons";
		group.tools.forEach((tool) => {
			const btn = document.createElement("button");
			btn.type = "button";
			btn.dataset.toolId = tool.id;
			btn.textContent = tool.label;
			btn.addEventListener("click", () => selectTool(tool.id));
			wrapper.appendChild(btn);
		});
		details.appendChild(wrapper);
		nav.appendChild(details);
	});
	updateToolButtons();
}

function initSidebarResizer() {
	let startX = 0;
	let startWidth = 0;
	const minWidth = 200;
	const maxWidth = 420;
	elements.resizer.addEventListener("mousedown", (event) => {
		startX = event.clientX;
		startWidth = elements.sidebar.offsetWidth;
		document.body.classList.add("resizing");
		const onMove = (e) => {
			const delta = e.clientX - startX;
			const newWidth = Math.min(
				maxWidth,
				Math.max(minWidth, startWidth + delta),
			);
			document.documentElement.style.setProperty(
				"--sidebar-width",
				`${newWidth}px`,
			);
		};
		const onUp = () => {
			document.body.classList.remove("resizing");
			document.removeEventListener("mousemove", onMove);
			document.removeEventListener("mouseup", onUp);
		};
		document.addEventListener("mousemove", onMove);
		document.addEventListener("mouseup", onUp);
	});
}

function bindEvents() {
	elements.from.addEventListener("change", ensureMode);
	elements.to.addEventListener("change", ensureMode);
	elements.swap.addEventListener("click", onSwap);
	elements.copy.addEventListener("click", copyOutput);
	elements.clear.addEventListener("click", clearAll);
	elements.input.addEventListener("input", () => scheduleConvert());
	elements.formatInput.addEventListener("click", () =>
		formatField(elements.input, elements.from.value, false),
	);
	elements.minifyInput.addEventListener("click", () =>
		formatField(elements.input, elements.from.value, true),
	);
	elements.formatOutput.addEventListener("click", () =>
		formatField(elements.output, elements.to.value, false),
	);
	elements.minifyOutput.addEventListener("click", () =>
		formatField(elements.output, elements.to.value, true),
	);
	elements.coderInput.addEventListener("input", () => scheduleCoder());
	if (elements.decodeVariant) {
		elements.decodeVariant.addEventListener("change", (event) => {
			selectedDecoder = event.target.value;
			updateCoderTexts();
			scheduleCoder(true);
		});
	}
	elements.coderResults.addEventListener("click", (event) => {
		const btn = event.target.closest("button[data-value]");
		if (!btn) return;
		const value = btn.dataset.value || "";
		if (!value) return;
		const label = btn.dataset.label || "結果";
		navigator.clipboard.writeText(value).then(
			() => setStatus(`已複製 ${label}`, false, "ready"),
			() => setStatus("無法存取剪貼簿", true),
		);
	});
	window.addEventListener("keydown", handleHotkeys);
}

function updateCoderTexts() {
	if (elements.coderWorkspaceTitle) {
		const modeTitle = coderModeTitles[coderMode] || coderMode;
		elements.coderWorkspaceTitle.textContent = `${modeTitle}`;
	}
	if (elements.coderModeHint) {
		elements.coderModeHint.textContent =
			coderModeDescriptions[coderMode] || "";
	}
	if (elements.coderResultHeading) {
		const heading =
			coderMode === "hash"
				? "Hash Digests"
				: coderMode === "decode"
					? "Decode"
					: "Encodings";
		elements.coderResultHeading.textContent = heading;
	}
	if (elements.coderResultHint) {
		if (coderMode === "decode") {
			const info = encodingVariantMap.get(selectedDecoder);
			elements.coderResultHint.textContent =
				info && info.group
					? `${info.group} · ${info.label}`
					: coderResultHints.decode;
		} else {
			elements.coderResultHint.textContent =
				coderResultHints[coderMode] || "";
		}
	}
	if (elements.decodeVariantWrap) {
		elements.decodeVariantWrap.classList.toggle(
			"hidden",
			coderMode !== "decode",
		);
	}
	if (elements.coderInput) {
		elements.coderInput.placeholder =
			coderPlaceholders[coderMode] || coderPlaceholders.encode;
	}
}

function renderCoderEmpty() {
	const message =
		coderMode === "decode"
			? "貼上要解碼的內容以查看結果"
			: "輸入內容以查看結果";
	elements.coderResults.innerHTML = `<div class="muted">${message}</div>`;
}

function renderEncodeResults(map) {
	if (!map || Object.keys(map).length === 0) {
		renderCoderEmpty();
		return;
	}
	const blocks = encodingGroups
		.map((group) => {
			const entries = group.variants
				.map((variant) => ({
					label: variant.label,
					value: map[variant.key],
					copyLabel: `${group.label} · ${variant.label}`,
				}))
				.filter((entry) => typeof entry.value === "string");
			if (!entries.length) return "";
			return renderGroupBlock(group.label, entries);
		})
		.filter(Boolean);
	if (blocks.length === 0) {
		renderCoderEmpty();
		return;
	}
	elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${blocks.join("")}</div>
    </div>
  `;
}

function renderDecodeResult(value, label) {
	const block = renderGroupBlock(label || "Decoded", [
		{
			label: label || "Decoded",
			value: value || "",
			copyLabel: label || "Decoded",
		},
	]);
	elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${block}</div>
    </div>
  `;
}

function renderHashResults(map) {
	if (!map || Object.keys(map).length === 0) {
		renderCoderEmpty();
		return;
	}
	const blocks = hashGroups
		.map((group) => {
			const entries = group.keys
				.map((key) => {
					const value = map[key];
					if (typeof value !== "string") {
						return null;
					}
					const label = hashLabels[key] || key;
					return {
						label,
						value,
						copyLabel: label,
					};
				})
				.filter(Boolean);
			if (!entries.length) return "";
			return renderGroupBlock(group.label, entries);
		})
		.filter(Boolean);
	if (blocks.length === 0) {
		renderCoderEmpty();
		return;
	}
	elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${blocks.join("")}</div>
    </div>
  `;
}

function renderGroupBlock(title, entries) {
	const rows = entries.map(renderEntryRow).join("");
	if (!rows.trim()) return "";
	const safeTitle = escapeHTML(title || "Result");
	return `
    <section class="coder-output-block">
      <header>${safeTitle}</header>
      <div class="coder-output-entries">
        ${rows}
      </div>
    </section>
  `;
}

function renderEntryRow(entry) {
	const safeLabel = escapeHTML(entry.label || "Result");
	const safeValue = escapeHTML(entry.value || "");
	const attrValue = escapeAttr(entry.value || "");
	const buttonLabel = escapeAttr(entry.copyLabel || entry.label || "Result");
	return `
    <div class="coder-entry">
      <div class="coder-entry-meta">
        <span>${safeLabel}</span>
        <button type="button" data-label="${buttonLabel}" data-value="${attrValue}">Copy</button>
      </div>
      <textarea readonly spellcheck="false">${safeValue}</textarea>
    </div>
  `;
}

function selectTool(toolId) {
	if (!toolInfo[toolId]) return;
	currentTool = toolId;
	const meta = toolInfo[toolId];
	elements.toolName.textContent = meta.label;
	elements.toolDesc.textContent = meta.description || "";
	const isFormat = toolId === "format";
	const isCoder = isCoderToolId(toolId);
	document.body.classList.toggle("tool-format", isFormat);
	document.body.classList.toggle("tool-coder", isCoder);
	elements.converterWorkspace.classList.toggle("hidden", !isFormat);
	elements.coderWorkspace.classList.toggle("hidden", !isCoder);
	updateToolButtons();
	if (isFormat) {
		ensureMode();
		scheduleConvert(true);
		return;
	}
	if (isCoder) {
		const nextMode = coderToolModes[toolId] || "encode";
		const changed = coderMode !== nextMode;
		coderMode = nextMode;
		updateCoderTexts();
		if (changed) {
			renderCoderEmpty();
		}
		scheduleCoder(true);
	}
}

function updateToolButtons() {
	document
		.querySelectorAll("#toolGroups button")
		.forEach((btn) =>
			btn.classList.toggle("active", btn.dataset.toolId === currentTool),
		);
}

function onSwap() {
	if (currentTool !== "format") return;
	const from = elements.from.value;
	const to = elements.to.value;
	elements.from.value = to;
	elements.to.value = from;
	const oldInput = elements.input.value;
	elements.input.value = elements.output.value;
	elements.output.value = oldInput;
	ensureMode();
}

function ensureMode() {
	if (currentTool !== "format") return false;
	const from = elements.from.value;
	const to = elements.to.value;
	if (!supportedFormats.has(from) || !supportedFormats.has(to)) {
		currentKey = null;
		return false;
	}
	currentKey = `${from}|${to}`;
	elements.inputLabel.textContent = from;
	elements.outputLabel.textContent = to;
	elements.input.placeholder = samples[from] || "";
	scheduleConvert(true);
	return true;
}

function scheduleConvert(immediate = false) {
	if (currentTool !== "format") return;
	if (immediate) {
		convert();
		return;
	}
	clearTimeout(debounceTimer);
	debounceTimer = setTimeout(() => convert(), 250);
}

function scheduleCoder(immediate = false) {
	if (!isCoderToolId(currentTool)) return;
	if (immediate) {
		runCoder();
		return;
	}
	clearTimeout(coderTimer);
	coderTimer = setTimeout(() => runCoder(), 200);
}

function convert() {
	if (currentTool !== "format") return;
	const from = elements.from.value;
	const to = elements.to.value;
	if (!supportedFormats.has(from) || !supportedFormats.has(to)) {
		setStatus("不支援的格式", true);
		return;
	}
	if (!wasmReady) {
		setStatus("等待 WebAssembly 載入...", true);
		return;
	}
	const raw = elements.input.value;
	if (!raw.trim()) {
		elements.output.value = "";
		setStatus("輸入為空，沒有輸出");
		return;
	}
	try {
		const result = window.transformFormat(from, to, raw);
		if (!result) {
			setStatus("WASM 尚未載入完成", true);
			return;
		}
		if (result.error) {
			elements.output.value = "";
			setStatus(`⚠️ ${result.error}`, true);
			return;
		}
		elements.output.value = result.result || "";
		setStatus("完成", false, "ready");
	} catch (err) {
		elements.output.value = "";
		setStatus(`⚠️ ${err.message}`, true);
	}
}

function runCoder() {
	if (!isCoderToolId(currentTool)) return;
	if (!wasmReady) {
		setStatus("等待 WebAssembly 載入...", true);
		return;
	}
	const text = elements.coderInput.value || "";
	const trimmed = text.trim();
	if (!trimmed && coderMode !== "hash") {
		renderCoderEmpty();
		return;
	}
	try {
		if (coderMode === "encode") {
			const response = window.encodeContent(text);
			if (!response) {
				setStatus("WASM 尚未載入完成", true);
				return;
			}
			if (response.error) {
				setStatus(`⚠️ ${response.error}`, true);
				return;
			}
			renderEncodeResults(response.result || {});
			setStatus("完成", false, "ready");
			return;
		}
		if (coderMode === "decode") {
			const decoderKey =
				selectedDecoder ||
				(elements.decodeVariant ? elements.decodeVariant.value : "");
			if (!decoderKey) {
				setStatus("請選擇要解碼的編碼", true);
				return;
			}
			const response = window.decodeContent(decoderKey, text);
			if (!response) {
				setStatus("WASM 尚未載入完成", true);
				return;
			}
			if (response.error) {
				setStatus(`⚠️ ${response.error}`, true);
				return;
			}
			const labelInfo = encodingVariantMap.get(decoderKey);
			const displayLabel = labelInfo
				? `${labelInfo.group} · ${labelInfo.label}`
				: "Decoded";
			renderDecodeResult(response.result || "", displayLabel);
			setStatus("完成", false, "ready");
			return;
		}
		const response = window.hashContent(text);
		if (!response) {
			setStatus("WASM 尚未載入完成", true);
			return;
		}
		if (response.error) {
			setStatus(`⚠️ ${response.error}`, true);
			return;
		}
		renderHashResults(response.result || {});
		setStatus("完成", false, "ready");
	} catch (err) {
		renderCoderEmpty();
		setStatus(`⚠️ ${err.message}`, true);
	}
}

function copyOutput() {
	if (currentTool !== "format") return;
	const text = elements.output.value;
	if (!text) {
		setStatus("沒有可複製的內容", true);
		return;
	}
	navigator.clipboard.writeText(text).then(
		() => setStatus("已複製到剪貼簿"),
		() => setStatus("無法存取剪貼簿", true),
	);
}

function clearAll() {
	if (isCoderToolId(currentTool)) {
		elements.coderInput.value = "";
		renderCoderEmpty();
		setStatus("已清除");
		return;
	}
	elements.input.value = "";
	elements.output.value = "";
	setStatus("已清除");
}

function handleHotkeys(e) {
	const mod = e.metaKey || e.ctrlKey;
	if (!mod) return;
	const key = e.key.toLowerCase();
	if (key === "l") {
		e.preventDefault();
		clearAll();
	} else if (key === "enter") {
		e.preventDefault();
		if (currentTool === "format") {
			scheduleConvert(true);
		} else if (isCoderToolId(currentTool)) {
			scheduleCoder(true);
		}
	}
}

function setStatus(text, isError = false, tone = "") {
	if (!elements.status) return;
	elements.status.textContent = text;
	if (isError) {
		elements.status.dataset.state = "error";
		return;
	}
	elements.status.dataset.state = tone || "";
}

function formatField(target, formatName, minify) {
	if (!wasmReady) {
		setStatus("等待 WebAssembly 載入...", true);
		return;
	}
	if (!supportedFormats.has(formatName)) {
		setStatus("不支援的格式", true);
		return;
	}
	const text = target.value;
	if (!text.trim()) {
		setStatus("沒有可處理的內容", true);
		return;
	}
	try {
		const result = window.formatContent(formatName, text, minify);
		if (!result) {
			setStatus("WASM 尚未載入完成", true);
			return;
		}
		if (result.error) {
			setStatus(`⚠️ ${result.error}`, true);
			return;
		}
		target.value = result.result || "";
		setStatus(minify ? "已壓縮" : "已格式化", false, "ready");
	} catch (err) {
		setStatus(`⚠️ ${err.message}`, true);
	}
}

function escapeHTML(input) {
	return input
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;");
}

function escapeAttr(input) {
	return escapeHTML(input).replace(/"/g, "&quot;");
}

async function loadWasm() {
	setStatus("載入 WebAssembly...");
	try {
		if (!wasmInitPromise) {
			wasmInitPromise = initWasm();
		}
		await wasmInitPromise;
		wasmReady = true;
		setStatus("WebAssembly 就緒，可以開始轉換！", false, "ready");
		if (currentTool === "format" && elements.input.value.trim()) {
			scheduleConvert(true);
		}
		if (isCoderToolId(currentTool)) {
			scheduleCoder(true);
		}
	} catch (err) {
		console.error(err);
		setStatus(`無法載入 WASM: ${err.message}`, true);
	}
}

async function initWasm() {
	if (typeof WebAssembly === "undefined") {
		throw new Error("瀏覽器不支援 WebAssembly");
	}
	if (typeof Go === "undefined") {
		throw new Error("wasm_exec.js 尚未載入");
	}
	const go = new Go();
	let instance;
	if (WebAssembly.instantiateStreaming) {
		const result = await WebAssembly.instantiateStreaming(
			fetch("app.wasm"),
			go.importObject,
		);
		instance = result.instance;
	} else {
		const response = await fetch("app.wasm");
		const bytes = await response.arrayBuffer();
		const result = await WebAssembly.instantiate(bytes, go.importObject);
		instance = result.instance;
	}
	go.run(instance);
}
